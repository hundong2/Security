# Argon2: 메모리-하드 패스워드 해시의 표준과 최신 동향
Argon2의 변형(Argon2d/i/id), 보안 설계, 권장 파라미터, 최신 업데이트를 요약하고 실무 코드/CLI 예제를 제공합니다.

## 예시 파일
[RFC 9106: Password Hashing with Argon2](https://www.rfc-editor.org/rfc/rfc9106.html)

## 답변
역사와 개요:
- PHC(Password Hashing Competition) 우승(2015): 기존 PBKDF2/bcrypt의 한계를 보완하기 위해 “메모리-하드(memory-hard)” 설계로 GPU/ASIC 병렬 공격을 비용 상승시키는 목표를 가짐.
- 변형: 
  - Argon2d(데이터 종속 메모리 접근, GPU 저항↑, 일부 사이드채널 주의)
  - Argon2i(데이터 비종속, 사이드채널 저항↑, GPU 저항은 d보다 낮음)
  - Argon2id(하이브리드, 현재 권장 기본값)
- 표준화: RFC 9106(2021)이 파라미터와 구현 지침을 정리. 광범위 라이브러리(lib­sodium, argon2-cffi, .NET 패키지 등)가 Argon2id를 기본 채택.

핵심 설계(비유 포함):
- 메모리-하드: 계산 중 큰 메모리 블록을 반복적으로 읽고 쓰게 만들어, GPU처럼 연산은 빠르지만 메모리 대역폭이 병목인 환경에서 공격 비용을 크게 올립니다. “좁은 문으로 많은 사람을 한 번에 못 지나가게 하는” 설계.
- 파라미터: 
  - `m`(memory, KiB 단위): 사용할 메모리 용량
  - `t`(time): 반복 횟수(패스 수)
  - `p`(parallelism): 병렬 스레드 수
  - `salt`(권장 ≥ 16바이트, 랜덤), `out_len`(권장 ≥ 32바이트)
- 안전 사용 원칙: Argon2id + 충분한 메모리 + 랜덤 16B 이상 솔트 + 해시 문자열에 파라미터를 함께 저장.

권장 파라미터(실무 감각, 2025):
- 서버(일반 웹): Argon2id, `m=64–256 MiB`, `t=2–4`, `p=1–4`, `salt=16B`, `out_len=32B`.
- 모바일/저사양: Argon2id, `m=32–64 MiB`, `t=3–4`, `p=1–2`(디바이스 성능에 맞춰 조정).
- 고감도(관리자·장기 비밀): Argon2id, `m=256 MiB–1 GiB`, `t=3–4`, `p=1–4`.
- 참고: 라이브러리별 “인터랙티브/모더레이트/센서티브” 프로파일 제공(lib­sodium 등). 운영환경 벤치마킹으로 응답시간(예: 100~500ms)을 목표에 맞게 맞추세요.

최신 업데이트(2024–2025 동향):
- 알고리즘 변경 없음: RFC 9106 안정. 보안 분석에서 실질적 취약 보고는 없으며, Argon2id 권장 기조 유지.
- 라이브러리 채택 확대: 
  - libsodium의 `crypto_pwhash` 기본 Argon2id 유지, 파라미터 프로파일 개선 문서화.
  - 파이썬(argon2-cffi), 자바(Kotlin) 등 생태계에서 Argon2id 기본 전환 지속.
- 플랫폼 지원: OpenSSL CLI는 Argon2 KDF를 직접 제공하지 않음(PBKDF2/scrypt만). .NET 런타임에도 내장 Argon2는 없음(외부 패키지 사용).
- 베스트 프랙티스: 길이 있는 랜덤 솔트, 해시 문자열에 파라미터 포함, 계정별·환경별 비용 조정, 비밀번호 정책과 유출 탐지 병행. 
- PQ(포스트양자) 맥락: 패스워드 해시는 양자 이점을 크게 주지 않음(메모리-하드 특성). 다만 키 유도에 사용하는 경우 출력 길이 32B 이상 유지 권장.

비교 요약:
- PBKDF2: 하드웨어 병렬에 취약(메모리 사용 낮음). FIPS 친화 환경에서 여전히 쓰이나 권장도는 Argon2 > scrypt > PBKDF2 순.
- bcrypt: 메모리 사용 제한적, 비트스트링 길이 제약 등 호환성 이슈. 
- scrypt: 메모리-하드지만 설계·튜닝 편의성과 생태계 측면에서 Argon2가 우세.

실무 체크리스트:
- Argon2id 사용, 솔트≥16B 랜덤, 해시 문자열에 파라미터 기록, 응답시간 기준으로 `m,t,p` 벤치마크 조정.
- 비밀번호 재해시 정책(로그인 시 파라미터 상향 필요 시 자동 재해시).
- 유출 대비 추가 보호(서버 측 rate-limit/lockout, breach corpuses와의 offline check).
- 해시 결과는 단방향 저장(복원 불가). 인증은 검증 절차로 처리.

코드 예제

```python
# Python: argon2-cffi (패스워드 해시/검증)
# 설치: pip install argon2-cffi
from argon2 import PasswordHasher

# 응답시간 목표에 맞춰 튜닝(예: ~200ms)
ph = PasswordHasher(
    time_cost=3,      # t
    memory_cost=65536,# m in KiB (≈64 MiB)
    parallelism=2,    # p
    hash_len=32,      # 출력 길이
    salt_len=16       # 솔트 길이
)

pwd = "CorrectHorseBatteryStaple!"
hash_str = ph.hash(pwd)         # 해시 생성(파라미터 포함된 문자열)
print("Hash:", hash_str)

# 검증(재해시 필요 시 ph.check_needs_rehash 사용)
try:
    ph.verify(hash_str, pwd)
    if ph.check_needs_rehash(hash_str):
        hash_str = ph.hash(pwd) # 파라미터 상향 시 재해시
except Exception as e:
    print("Verify failed:", e)
```

```cpp
// C++: libsodium (Argon2id) - 키 유도/패스워드 해시
// 준비: brew install libsodium
// 빌드: clang++ main.cpp -lsodium -o argon2id_demo
#include <sodium.h>
#include <iostream>
#include <vector>

int main(){
    if (sodium_init() < 0) return 1;
    const char* pwd = "CorrectHorseBatteryStaple!";
    std::vector<unsigned char> salt(crypto_pwhash_SALTBYTES);
    randombytes_buf(salt.data(), salt.size());

    std::vector<unsigned char> out(32);
    // Argon2id, 'interactive' 프로파일 예시(응답시간에 맞추어 조정)
    if (crypto_pwhash(out.data(), out.size(),
                      pwd, strlen(pwd),
                      salt.data(),
                      crypto_pwhash_OPSLIMIT_MODERATE,
                      crypto_pwhash_MEMLIMIT_MODERATE,
                      crypto_pwhash_ALG_ARGON2ID13) != 0) {
        std::cerr << "Derive failed\n"; return 1;
    }
    std::cout << "Derived 32-byte key.\n";
    return 0;
}
```

```csharp
// C#: Konscious.Security.Cryptography.Argon2id
// 준비: dotnet add package Konscious.Security.Cryptography.Argon2
using System;
using System.Security.Cryptography;
using System.Text;
using Konscious.Security.Cryptography;

class Program {
  static void Main() {
    var pwd = Encoding.UTF8.GetBytes("CorrectHorseBatteryStaple!");
    var salt = RandomNumberGenerator.GetBytes(16);

    var argon = new Argon2id(pwd) {
      DegreeOfParallelism = 2, // p
      Iterations = 3,          // t
      MemorySize = 64 * 1024   // m in KiB (64 MiB)
    };
    argon.Salt = salt;
    var key = argon.GetBytes(32);
    Console.WriteLine($"Key(32B): {BitConverter.ToString(key).Replace("-", "")}");
  }
}
```

OpenSSL 실습(연계: 솔트/IV 생성 및 암호화)
- 참고: OpenSSL CLI는 Argon2 KDF를 직접 제공하지 않습니다(PBKDF2/scrypt는 제공). Argon2로 유도한 키를 OpenSSL 암복호화에 사용할 수 있습니다.

```sh
# 1) 랜덤 솔트/IV 생성
openssl rand -hex 16   # 솔트(16B)
openssl rand -hex 12   # GCM IV(12B 권장)

# 2) (예) Python에서 Argon2로 32B 키를 HEX로 출력 후 변수에 저장했다고 가정
#   KEYHEX=<argon2로 유도한 32바이트 키의 hex>
#   IVHEX=<위에서 생성한 IV hex>

# 3) AES-256-GCM 암호화(키/IV 직접 지정)
# 파일 암호화
openssl enc -aes-256-gcm -K "$KEYHEX" -iv "$IVHEX" -in secret.txt -out secret.bin -p

# 4) 복호화(동일 키/IV)
openssl enc -d -aes-256-gcm -K "$KEYHEX" -iv "$IVHEX" -in secret.bin -out recovered.txt
diff secret.txt recovered.txt  # 동일 확인
```

추가 팁:
- 해시 문자열 저장: 라이브러리 포맷(예: `$argon2id$v=19$m=65536,t=3,p=2$...`)을 그대로 DB에 저장해 파라미터와 솔트를 재사용.
- 벤치마크: 로그인 시 평균 응답시간 목표(예: 200ms)를 정해 `m,t,p`를 조정. CPU/메모리·동시성에 따라 다릅니다.
- 재해시 정책: 파라미터 상향 필요 감지 시(login 성공) 새 파라미터로 재해시 후 저장.
- 서버 보호: 온라인 공격 방지용 rate-limit, lockout, breach corpus 검사 병행.

### 추가 자료
- [RFC 9106: Argon2 표준](https://www.rfc-editor.org/rfc/rfc9106.html)
- [Argon2 레퍼런스 구현(GitHub)](https://github.com/P-H-C/phc-winner-argon2)
- [libsodium crypto_pwhash(Argon2id) 문서](https://doc.libsodium.org/password_hashing/default)
- [argon2-cffi(Python) 문서](https://argon2-cffi.readthedocs.io/en/stable/)
- [OWASP Password Storage Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Password_Storage_Cheat_Sheet.html)


용어사전:
- Argon2id: 데이터 종속/비종속 단계 혼합한 변형. 현재 권장 기본.
- 메모리-하드: 많은 메모리와 대역폭을 요구해 병렬 하드웨어 공격 비용을 높이는 설계.
- `m`/`t`/`p`: 메모리 용량(KiB)/반복 횟수/병렬 스레드 수.
- 솔트: 사용자별 랜덤 값(재사용 금지)으로 해시를 고유화.
- 해시 문자열 포맷: 파라미터·솔트·출력 해시를 함께 인코딩한 저장 형식.
- 재해시: 더 강한 파라미터로 다시 해시해 저장을 갱신하는 운영 절차.
- PBKDF2/bcrypt/scrypt: 패스워드 해시 선행 기법; Argon2가 메모리-하드성과 튜닝 편의성에서 우수.
- GCM IV: AES-GCM의 12바이트 권장 초기화 벡터(Nonce).